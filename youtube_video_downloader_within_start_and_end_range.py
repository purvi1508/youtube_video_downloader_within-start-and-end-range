# -*- coding: utf-8 -*-
"""youtube_video_downloader_within start and end range

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/118OdfTZtZw4vls91BJwqFL7KeI2CBzzf
"""

!pip install pytube
!pip install moviepy

import os
import csv
from pytube import YouTube
from moviepy.editor import *
from pytube import exceptions

# Replace CSV_FILE_PATH with the actual path to your CSV file
CSV_FILE_PATH = "/content/Book1.csv"

# Loop through each row in the CSV file
with open(CSV_FILE_PATH, newline='') as csvfile:
    reader = csv.reader(csvfile)
    next(reader)  # skip the header row
    
    # Loop through each row in the CSV file
    for row in reader:
        # Extract the video ID, class name, start time, and end time from the row
        video_id = row[1]
        class_name = row[0]
        start_time = float(row[3])
        end_time = float(row[4])
        
        # Create a YouTube object with the video URL
        url = f"https://www.youtube.com/watch?v={video_id}"
        yt = YouTube(url)

        try:
            # Get the highest resolution video stream
            stream = yt.streams.get_highest_resolution()
        except exceptions.VideoUnavailable:
            print(f"Video {video_id} is unavailable. Skipping...")
            continue
        except KeyError:
            print(f"Video {video_id} has no streaming data. Skipping...")
            continue
        except exceptions.RegexMatchError:
            print(f"Invalid video URL: {row[1]}. Skipping...")
            continue

        # Set the output file name with the class name and video ID
        output_file = f"{class_name}_{video_id}.mp4"

        # Create a folder with the class name if it doesn't exist
        folder_path = f"./{class_name}"
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)

        # Download the portion of the video to the folder
        stream.download(output_path=folder_path, filename=output_file)

        # Create a subclip using moviepy if the start time is smaller than the duration, and save it to the folder
        video_path = os.path.join(folder_path, output_file)
        video = VideoFileClip(video_path)
        if start_time < video.duration:
            # Check if the end time is greater than the duration and set it to the duration if it is
            if end_time > video.duration:
                end_time = video.duration
            
            subclip = video.subclip(start_time, end_time)
            subclip_file = f"{class_name}_{video_id}_subclip.mp4"
            subclip_path = os.path.join(folder_path, subclip_file)
            subclip.write_videofile(subclip_path)
            video.close()
        else:
            print(f"Start time for video {video_id} is greater than its duration. Skipping...")
            video.close()

import os
import zipfile

# List of folder paths to zip
folders = ['/content/Archery', '/content/Kite flying', '/content/Knitting','/content/Painting furniture','/content/Running a marathon','/content/Tug of war','/content/Volleyball','/content/Walking the dog']

# Output zip file path
zip_file_path = '/content/combined_folders.zip'

# Create a new zip file
with zipfile.ZipFile(zip_file_path, 'w') as zip_file:
    # Loop through each folder and add its contents to the zip file
    for folder in folders:
        # Loop through each file in the folder
        for root, dirs, files in os.walk(folder):
            for file in files:
                # Create the full file path by joining the folder path and file name
                file_path = os.path.join(root, file)
                # Add the file to the zip file
                zip_file.write(file_path, arcname=os.path.relpath(file_path, folder))

